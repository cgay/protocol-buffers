Module: protocol-buffers-impl
Synopsis: Generate Dylan code from a <file-descriptor-proto>


// Potential options for code generation:
// * Make exporting setters optional.


// Output a module definition to `stream`. If `library-name` is provided, then
// also output a library definition. The library is optional so that Dylan
// protobuf code can be compiled directly into another library.
//
// TODO: this will eventually need to accept a <file-descriptor-set> instead.
// Keeping it simple for now.
define function generate-dylan-module
    (file :: <file-descriptor-proto>,
     #key stream :: <stream> = *standard-output*,
          library-name :: false-or(<string>))
 => ()
  format(stream, $module-header);
  if (library-name)
    format(stream, $library-template, library-name);
  end;
  let module-name
    = map(method (ch)
            iff((ch == '.' | ch == '_'), '-', ch)
          end,
          file-descriptor-proto-package(file));
  format(stream, $module-template,
         module-name,
         join(map(curry(concat, "    "),
                  module-exports(file)),
              ",\n"));
end function generate-dylan-module;

define constant $module-header
  = """Module: dylan-user

// *** This code was automatically generated by pbgen. ***

""";

define constant $library-template
  = """define library %s
  use common-dylan;
  use protocol-buffers;
end library;

""";

define constant $module-template
  = """define module %s
  use common-dylan;
  use protocol-buffers;

  export
%s;
end module;
""";

define function module-exports
    (file :: <file-descriptor-proto>) => (exports :: <seq>)
  let names = make(<stretchy-vector>);
  // messages
  for (message in file-descriptor-proto-message-type(file) | #[])
    let message-name = dylan-name(descriptor-proto-name(message));
    add!(names, concat("<", message-name, ">"));
    for (field in descriptor-proto-field(message) | #[])
      let field-name = field-descriptor-proto-name(field);
      let getter = concat(message-name, "-", dylan-name(field-name));
      add!(names, getter);
      add!(names, concat(getter, "-setter"));
    end;
  end;
  // enums
  for (enum in file-descriptor-proto-enum-type(file) | #[])
    let enum-name = dylan-name(enum-descriptor-proto-name(enum));
    add!(names, concat("<", enum-name, ">"));
    add!(names, concat(enum-name, "-name"));
    add!(names, concat(enum-name, "-value"));
    for (enum-value in enum-descriptor-proto-value(enum))
      let value-name
        = dylan-name(enum-value-descriptor-proto-name(enum-value));
      let enum-value-name
        = concat("$", enum-name, "-", value-name);
      add!(names, enum-value-name);
    end;
  end;
  names
end function module-exports;

define function generate-dylan-code
    (file :: <file-descriptor-proto>,
     #key stream :: <stream> = *standard-output*)
 => ()
end function generate-dylan-code;

define function dylan-name
    (proto-name :: <string>) => (dylan-name :: <string>)
  camel-to-kebob(proto-name)
end function;

define function dylan-class-name
    (proto-name :: <string>) => (dylan-name :: <string>)
  concat("<", camel-to-kebob(proto-name), ">")
end function;

// Convert `camel` from CamelCase to kebob-case.
//
//   camel-to-kebob("CamelCase")            => "camel-case"
//   camel-to-kebob("TCPConnection")        => "tcp-connection"
//   camel-to-kebob("NewTCPConnection")     => "new-tcp-connection"
//   camel-to-kebob("new_RPC_DylanService") => "new-rpc-dylan-service"
//   camel-to-kebob("RPC_DylanService_get_request") => "rpc-dylan-service-get-request"
//   camel-to-kebob("TCP2Name3")            => "tcp2-name3"
//
// Caller is responsible for adding decorations such as "<" and ">" for class
// names.  Note that this function is not reversible, i.e., it is lossy
// w.r.t. the original name.
define function camel-to-kebob (camel :: <string>) => (kebob :: <string>)
  let len = camel.size;
  if (len == 0)
    ""
  else
    iterate loop (i = 1,
                  state = #"start",
                  chars = list(as-lowercase(camel[0])))
      if (i >= len)
        as(<string>, reverse!(chars))
      else
        let ch = camel[i];
        case
          // TODO: after upgrading to strings@2.0 remove calls to alphabetic?.
          alphabetic?(ch) & uppercase?(ch) =>
            loop(i + 1, #"upper",
                 select (state)
                   #"upper" =>
                     // TCPConnection => tcp-connection
                     iff((i + 1 < len) & alphabetic?(camel[i + 1]) & lowercase?(camel[i + 1]),
                         pair(as-lowercase(ch), pair('-', chars)),
                         pair(as-lowercase(ch), chars));
                   #"lower" =>
                     pair(as-lowercase(ch), pair('-', chars));
                   otherwise =>
                     pair(as-lowercase(ch), chars);
                 end);
          // TODO: after upgrading to strings@2.0 combine these two clauses
          // into one using alphanumeric?.
          alphabetic?(ch) & lowercase?(ch) =>
            loop(i + 1, #"lower", pair(ch, chars));
          decimal-digit?(ch) =>
            loop(i + 1, #"lower", pair(ch, chars));
          ch == '-' | ch == '_' =>
            loop(i + 1, #"start", pair('-', chars));
          ch == '.' =>
            loop(i + 1, #"start", pair('.', chars));
          otherwise =>
            pb-error("invalid name character: %=", ch);
        end case
      end if
    end iterate
  end
end function camel-to-kebob;
